export type StackEvent = ErrorEvent | PromiseRejectionEvent | Error | string;

export type Range = number | [number, number];

/**
 * Configuration options for parsing a stack trace.
 */
export interface StackTraceParseOptions {
    /**
     * Specifies the range of stack frames to include in the parsed result.
     * Can be a single number (starting index) or a tuple `[start, end]` (inclusive range).
     * Helps optimize performance by limiting the stack frames to process.
     *
     * @example
     * slice: 2 // Start from the 2nd frame to the end
     * slice: [1, 4] // Include frames from index 1 to index 4
     */
    frameRange?: Range

    /**
     * Determines behavior when the stack trace is not found.
     * - If `true`, returns an empty result instead of throwing an error.
     * - If `false` (default), throws an error when the stack is not available.
     *
     * @default false
     */
    allowMissing?: boolean;
}

/**
 * Represents a single frame in a stack trace.
 */
export interface StackFrame {
    /**
     * The file or script where the error occurred.
     * Can be a URL, a local file path, or `undefined` if not available.
     * 
     * @example "http://example.com/script.js"
     * @example "C:/path/to/file.js"
     */
    filename?: string;

    /**
     * The column number in the file where the error occurred.
     * This is often provided by modern JavaScript engines.
     * 
     * @example 15
     */
    colno?: number;

    /**
     * The line number in the file where the error occurred.
     * Indicates the approximate location of the error in the source file.
     * 
     * @example 42
     */
    lineno?: number;

    /**
     * The raw stack trace string generated by the JavaScript engine.
     * Contains detailed information about the call stack at the time of the error.
     * 
     * @example
     * "Error: Something went wrong\n    at foo (http://example.com/script.js:10:15)\n    at bar (native)"
     */
    stack: string;

    /**
     * The error message associated with the frame.
     * Describes the nature of the error, such as a reference or type error.
     * 
     * @example "ReferenceError: foo is not defined"
     */
    message: string;

    /**
     * The type of error represented by this stack frame.
     * Typically corresponds to the error name, such as `TypeError` or `ReferenceError`.
     * 
     * @example "ReferenceError"
     * @example "TypeError"
     */
    type: string;

    /**
     * The HTML element associated with the error (if applicable).
     * This is the tag name of the element where the error occurred or was triggered.
     * 
     * @example "img"
     * @example "script"
     */
    element?: keyof HTMLElementTagNameMap;

    /**
    * A hyperlink reference related to the error.
    * Can be a source URL or a path indicating the origin of the problem, such as a failed resource.
    * 
    * @example "http://example.com/resource.js"
    * @example "/assets/missing-image.png"
    */
    link?: string;
}


/**
 * Regular expression to match stack trace lines from Chrome and IE.
 * 
 * ```ts
 * Error: Example error
 *  at foo (http://example.com/script.js:10:15)
 *  at bar (native)
 *  at Function.prototype.call (C:/path/to/file.js:20:5)
 *  at eval (eval at <anonymous> (http://example.com/script.js:30:10), <anonymous>:1:1)
 * ```
 */
const CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m

/**
 * Type guard to determine if the provided event is a PromiseRejectedResult.
 * Differentiates between ErrorEvent and PromiseRejectedResult by checking
 * for the presence of the `reason` property.
 *
 * @param event - The event to check, which can be an ErrorEvent or a PromiseRejectedResult.
 * @returns True if the event is a PromiseRejectedResult, otherwise false.
 */
function isPromiseRejectionEvent<T extends PromiseRejectionEvent = PromiseRejectionEvent>(
    event: PromiseRejectionEvent | ErrorEvent | Error
): event is T {
    return 'reason' in event;
}

function serialize<T extends StackEvent>(event: T, space: number = 2): string {
    return JSON.stringify(event, null, space);
}

function applySlice<T>(lines: T[], options?: StackTraceParseOptions) {
    if (options && options.frameRange != null) {
        if (Array.isArray(options.frameRange))
            return lines.slice(options.frameRange[0], options.frameRange[1])
        return lines.slice(0, options.frameRange)
    }
    return lines
}

/**
 * Extracts the file path, line number, and column number from a URL-like string.
 *
 * @param urlLike - The URL-like string to parse. Typically represents a stack frame location,
 * such as a script file with optional line and column information.
 * 
 * @returns A tuple containing:
 * - The file path or script name (e.g., "http://example.com/script.js" or "(native)").
 * - The line number (if present), or `undefined`.
 * - The column number (if present), or `undefined`.
 *
 * @example
 * extractLocation("http://example.com/script.js:10:15");
 * // Returns: ["http://example.com/script.js", "10", "15"]
 *
 * @example
 * extractLocation("http://example.com/script.js:10");
 * // Returns: ["http://example.com/script.js", "10", undefined]
 *
 * @example
 * extractLocation("(native)");
 * // Returns: ["native", undefined, undefined]
 */
export function parseLocation(urlLike: string): [string, string | undefined, string | undefined] {
    // Fast path: If the string does not contain a colon, treat it as a single location.
    if (!urlLike.includes(':')) {
        return [urlLike, undefined, undefined];
    }

    // Regular expression to capture the file path, line number, and column number.
    const regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;

    // Remove parentheses and match the string against the regular expression.
    const parts = regExp.exec(urlLike.replace(/[()]/g, ''))!;

    // Return the matched groups, ensuring undefined for missing line or column numbers.
    return [parts[1], parts[2] || undefined, parts[3] || undefined] as const;
}

export function parseStack(error: Error, options?: StackTraceParseOptions) {
    // @ts-expect-error missing stacktrace property
    if (typeof (error).stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {
        return parseOpera(error, options)
    } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
        return parseV8OrIE(error, options);
    } else if (error.stack) {
        return parseFFOrSafari(error);
    } else if (options?.allowMissing) {
        return {} as StackFrame
    } else {
        return {
            type: 'unknow error',
            message: 'unknow error',
            stack: serialize(error)
        } as StackFrame
    }
}

export function parseOpera(error: Error, options?: StackTraceParseOptions) {

}

export function parseFFOrSafari(error: Error, options?: StackTraceParseOptions) {

}

export function parseV8OrIE(error: Error, options?: StackTraceParseOptions) {
    return parseV8OrIeString(error, error.stack!, options);
}

export function parseV8OrIeString(error: Error, stack: string, options?: StackTraceParseOptions) {
    const filtered = applySlice(
        stack.split('\n').filter((line) => {
            return !!line.match(CHROME_IE_STACK_REGEXP)
        }),
        options,
    )

    console.log(filtered)
}

export function parseError<T>(input: T) {
    if (input instanceof Error) {

    }
}

export function parseErrorEvent(error: ErrorEvent) {

}

export function parsePromiseRejectionEvent(error: PromiseRejectionEvent) {

}

export function parse<T extends StackEvent = StackEvent>(input: T) {
    if (typeof input === 'string') {
        return {
            type: "error",
            message: input,
            stack: serialize(input)
        } as StackFrame;
    }

    if (isPromiseRejectionEvent(input)) {
        return parseStack(input.reason)
    }

    if (input instanceof Error) {
        return parseStack(input)
    }

    const { target } = input
    if (target instanceof HTMLElement) {
        if (target.nodeType === 1 || target.localName) {
            const frame = {
                type: input.type,
                element: target.localName || target.nodeName.toLowerCase(),
                stack: serialize(input)
            } as StackFrame;

            switch (target.nodeName.toLowerCase()) {
                case 'link':
                    frame.link = (target as HTMLLinkElement).href
                    break
                default:
                    frame.link =
                        (target as HTMLImageElement).currentSrc ||
                        (target as HTMLScriptElement).src
            }

            frame.message = `Unable to load "${frame.link}"`

            return frame
        }
    }

    if (input.error || input instanceof ErrorEvent) {
        const e = input.error
        e.fileName = e.filename || input.filename
        e.columnNumber = e.colno || input.colno
        e.lineNumber = e.lineno || input.lineno

        return parseStack(e)
    }

    return {
        type: "unknown error",
        message: input,
        stack: serialize(input || '')
    } as StackFrame
}